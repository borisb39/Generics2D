/**
* The SpacePartitionWorld class defines a 2D physical world
* where a 2D spatial partition is used for handling collisions between entities
*
* @file SpacePartionWorld.h
* @author Boris Burdin
* @date 20220212 - Move boundary check in dedicated struct
*                  Add  Boundaries struct, Update updateDynamicBodies method
* @date 20220212 - addBody -> createBody
* @date 20220212 - Backward update
*                  Update method updateDynamicBodies
* @date 20220207 - External Access dynamic bodies + bugfixes delete listener/world
*                  Update methods ~SpacePartitionWorld, createBody,setContactListener
*                  Add method getDynamicBodyAt, attribut mDynamicBodiesExternalAccess
* @date 20220116 - Add Contact Listener
*                  AAdd Step metod, contactListener attribut
*                  Update methods createBody,  updateDynamicBodies
* @date 20220107 - Code refactoring to manage colliders as world factory objects
*                  Update createBody method, create mCollidersattribut
* @date 20220106 - Move collisionResolutionDynamicVSstaticBodies in SpacePartitionBody
* @date 20211215 - Generic method to catch elapsed time for dynamic bodies 
*                  Add method updateDynamicBodies, getters for number of bodies
*                  Update methods createBody,collisionResolutionDynamicVSstaticBodies
* @date 20211128 - Algo for Min collision detection
*                  Add method collisionResolutionDynamicVSstaticBodies_Min
*                  Update method collisionResolutionMeanDynamicVSstaticBodies > collisionResolutionMeanDynamicVSstaticBodies_Mean
* @date 20211113 add static method collisionResolutionMeanDynamicVSstaticBodies
* @date 20210425 - Initial Release
*/

#pragma once

#include "Generics_types.h"

namespace Generics
{
	/// Boundary checking
	/// +saves the minimum and maximum displacement values in each direction
	///  generated by the collisions with the associated body neighborhood
	/// +computes the final displacement resulting from these collisions
	struct Boundaries
	{
		float positive_dispx = 0;
		float negative_dispx = 0;;
		float positive_dispy = 0;;
		float negative_dispy = 0;
		void update(Collision collision)
		{
			positive_dispx = fmax(positive_dispx, collision.response.x);
			negative_dispx = fmin(negative_dispx, collision.response.x);
			positive_dispy = fmax(positive_dispy, collision.response.y);
			negative_dispy = fmin(negative_dispy, collision.response.y);
		}
		Vect2d correction()
		{
			// the mean displacement value in each direction is returned.
			// avoid 0 division (2->2, 1->1, 0->1)
			float divx = (positive_dispx != 0 && negative_dispx != 0) ? 2.f : 1.f;
			float divy = (positive_dispy != 0 && negative_dispy != 0) ? 2.f : 1.f;
			Vect2d correction = {
				(positive_dispx + negative_dispx) / divx,
				(positive_dispy + negative_dispy) / divy
			};
			return correction;
		}
	};

	/// The SpacePartitionWorld base class 
	class SpacePartitionWorld
	{
	public:


		/**
		* Constructor. Used to create a container (world) for the management
		* of bodies and colliders. The bodies are referenced in a Grid where the collision detection
		* is done in an efficiant way. 
		* @Parameters 
		*	int nx : nb of cells along x in the Grid 
		*	int ny : nb of cells along y in the Grid 
		*	width and height : the Grid size
		*/
		SpacePartitionWorld(int nx, int ny, float width, float height);

		/**
		* Destructor
		*/
		~SpacePartitionWorld();

		/**
		* createBody will create add in the World container a new body based on the provided <bodyTemplate>, and reference it in the Grid.
		*/
		SpacePartitionBody* createBody(SpacePartitionBodyTemplate bodyTemplate);

		/**
	    * getDynamicBodyAt will get a ptr of
	    * the body refered at indice <idx> in the world dynamicBodies container.
	    * In case of out of bound indice a nullptr is returned.
	    */
		SpacePartitionBody* getDynamicBodyAt(int idx);

		/**
		* Step is called at each solver step loop and lists all the operations performed during a step of calculation.
		*/
		void Step(double dt);

		/**
		* updateDynamicBodies will update the dynamic bodies state to catch the elasped time <dt> with respect of
		* the static bodies limitations. If a contact listener is associated to the world the contacts state between bodies 
		* will be tracked.
		*/
		void updateDynamicBodies(double dt);

		// Getters for number of bodies
		int totalBodiesNumber() const { return mStaticBodies.size() + mDynamicBodies.size(); }
		int dynamicBodiesNumber() const { return mDynamicBodies.size(); }
		int staticBodiesNumber() const { return mStaticBodies.size(); }

		// Getter and Setter for contact listener
		SpacePartitionContactListener* getContactListener() const { return mContactListener; };
		void setContactListener(SpacePartitionContactListener * contactListener);

	private:

		// Container of Static bodies 
		std::list<SpacePartitionBody> mStaticBodies;
		// Container of Dynamic bodies 
		std::list<SpacePartitionBody> mDynamicBodies;
		std::vector< SpacePartitionBody*> mDynamicBodiesExternalAccess;
		// Container of colliders
		std::list<SpacePartitionCollider> mColliders;
		// 2D partition Grid where mStaticBodies and mDynamicBodies are referenced.
		SpacePartitionGrid* mGrid;

		// track contacts between bodies
		SpacePartitionContactListener* mContactListener = nullptr;
	};

}